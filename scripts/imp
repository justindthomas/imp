#!/usr/bin/env python3
"""
imp - IMP Router Management CLI

Usage:
    imp                       Enter interactive configuration REPL
    imp config apply          Apply configuration from /persistent/config/router.json
    imp config edit           Edit configuration interactively
    imp shell routing         Open FRR/vtysh shell (routing protocols)
    imp shell core            Open VPP core instance CLI
    imp shell <module>        Open VPP module CLI (e.g., nat, nat64)
    imp snapshot list         List all snapshots
    imp snapshot create       Create a snapshot of current system
    imp snapshot rollback     Restore from a snapshot (creates new boot environment)
    imp snapshot delete       Delete a snapshot
    imp snapshot export       Export snapshot to file (for deployment or backup)
    imp snapshot import       Import system from file
    imp status                Show service status
"""

import argparse
import json
import os
import subprocess
import sys
from datetime import datetime
from pathlib import Path


# =============================================================================
# Configuration
# =============================================================================

CONFIG_FILE = Path("/persistent/config/router.json")
VPP_CORE_SOCKET = "/run/vpp/core-cli.sock"
VPP_NAT_SOCKET = "/run/vpp/nat-cli.sock"
DATAPLANE_NS = "dataplane"
ZFS_POOL = "tank"
ZFS_ROOT = f"{ZFS_POOL}/ROOT"
ZFS_PERSISTENT = f"{ZFS_POOL}/persistent"


# =============================================================================
# Colors
# =============================================================================

class Colors:
    RED = "\033[0;31m"
    GREEN = "\033[0;32m"
    YELLOW = "\033[1;33m"
    CYAN = "\033[0;36m"
    BOLD = "\033[1m"
    NC = "\033[0m"


def log(msg: str) -> None:
    print(f"{Colors.GREEN}[+]{Colors.NC} {msg}")


def warn(msg: str) -> None:
    print(f"{Colors.YELLOW}[!]{Colors.NC} {msg}")


def error(msg: str) -> None:
    print(f"{Colors.RED}[ERROR]{Colors.NC} {msg}")


# =============================================================================
# Config Commands
# =============================================================================

def cmd_config_apply(args) -> int:
    """Apply configuration from persistent storage."""
    if not CONFIG_FILE.exists():
        error(f"No configuration found at {CONFIG_FILE}")
        print("\nRun 'imp config edit' to create a configuration.")
        return 1

    log(f"Applying configuration from {CONFIG_FILE}")
    result = subprocess.run(
        ["/usr/local/bin/configure-router", "--apply-only"],
        check=False
    )
    return result.returncode


def cmd_config_edit(args) -> int:
    """Run interactive configuration."""
    log("Starting interactive configuration...")
    result = subprocess.run(
        ["/usr/local/bin/configure-router"],
        check=False
    )
    return result.returncode


def cmd_config_show(args) -> int:
    """Show current configuration."""
    if not CONFIG_FILE.exists():
        error(f"No configuration found at {CONFIG_FILE}")
        return 1

    import json
    with open(CONFIG_FILE) as f:
        config = json.load(f)

    print(json.dumps(config, indent=2))
    return 0


# =============================================================================
# Shell Commands
# =============================================================================

def cmd_shell_routing(args) -> int:
    """Open FRR vtysh shell in dataplane namespace."""
    # Check if namespace exists
    ns_path = Path(f"/var/run/netns/{DATAPLANE_NS}")
    if not ns_path.exists():
        error(f"Dataplane namespace '{DATAPLANE_NS}' not found")
        print("\nIs the dataplane running? Check: systemctl status netns-dataplane")
        return 1

    log("Entering FRR routing shell (vtysh)...")
    print("Type 'exit' to return\n")

    result = subprocess.run(
        ["ip", "netns", "exec", DATAPLANE_NS, "vtysh"],
        check=False
    )
    return result.returncode


def cmd_shell_core(args) -> int:
    """Open VPP core instance CLI."""
    if not Path(VPP_CORE_SOCKET).exists():
        error(f"VPP core socket not found: {VPP_CORE_SOCKET}")
        print("\nIs VPP core running? Check: systemctl status vpp-core")
        return 1

    log("Entering VPP core CLI...")
    print("Type 'quit' to return\n")

    result = subprocess.run(
        ["vppctl", "-s", VPP_CORE_SOCKET],
        check=False
    )
    return result.returncode


def cmd_shell(args) -> int:
    """Route shell command to appropriate handler."""
    target = getattr(args, "target", None)

    if not target:
        # Show available shells
        print(f"\n{Colors.BOLD}Available shells:{Colors.NC}")
        print("  routing    FRR/vtysh (BGP, OSPF)")
        print("  core       VPP core instance")

        # List enabled modules
        modules = get_enabled_modules()
        for service_name, display_name in modules:
            module_name = service_name.replace("vpp-", "")
            print(f"  {module_name:<10} {display_name}")

        # Also list any running module sockets not in config
        try:
            vpp_sockets = list(Path("/run/vpp").glob("*-cli.sock"))
            known_names = {"core"} | {s.replace("vpp-", "") for s, _ in modules}
            for sock in vpp_sockets:
                name = sock.name.replace("-cli.sock", "")
                if name not in known_names:
                    print(f"  {name:<10} (running, not in config)")
        except Exception:
            pass

        print(f"\nUsage: imp shell <target>")
        return 0

    # Route to handler
    if target in ("routing", "frr", "vtysh"):
        return cmd_shell_routing(args)
    elif target in ("core", "vpp"):
        return cmd_shell_core(args)
    else:
        # Treat as module name
        args.module_name = target
        return cmd_shell_module(args)


def cmd_shell_module(args) -> int:
    """Open VPP module instance CLI."""
    module_name = args.module_name
    socket_path = f"/run/vpp/{module_name}-cli.sock"

    if not Path(socket_path).exists():
        error(f"VPP {module_name} socket not found: {socket_path}")
        print(f"\nIs vpp-{module_name} running? Check: systemctl status vpp-{module_name}")

        # List available module sockets
        vpp_sockets = list(Path("/run/vpp").glob("*-cli.sock"))
        module_sockets = [s for s in vpp_sockets if s.name != "core-cli.sock"]
        if module_sockets:
            print("\nAvailable module sockets:")
            for sock in module_sockets:
                name = sock.name.replace("-cli.sock", "")
                print(f"  {name}")
        return 1

    # Try to get display name from module definition
    display_name = module_name
    module_yaml = Path(f"/persistent/config/modules/{module_name}.yaml")
    if module_yaml.exists():
        try:
            import yaml
            with open(module_yaml) as f:
                mod_def = yaml.safe_load(f)
                if mod_def and mod_def.get("display_name"):
                    display_name = mod_def["display_name"]
        except Exception:
            pass

    log(f"Entering {display_name} CLI...")
    print("Type 'quit' to return\n")

    result = subprocess.run(
        ["vppctl", "-s", socket_path],
        check=False
    )
    return result.returncode


# =============================================================================
# Status Command
# =============================================================================

def get_enabled_modules() -> list[tuple[str, str]]:
    """Get list of enabled modules from router.json.

    Returns list of (service_name, display_name) tuples.
    """
    if not CONFIG_FILE.exists():
        return []

    try:
        with open(CONFIG_FILE) as f:
            config = json.load(f)

        modules = []
        for mod in config.get("modules", []):
            if mod.get("enabled", False):
                name = mod.get("name", "")
                if name:
                    # Try to load module definition for display name
                    display_name = f"VPP {name} module"
                    module_yaml = Path(f"/persistent/config/modules/{name}.yaml")
                    if module_yaml.exists():
                        try:
                            import yaml
                            with open(module_yaml) as mf:
                                mod_def = yaml.safe_load(mf)
                                if mod_def and mod_def.get("display_name"):
                                    display_name = mod_def["display_name"]
                        except Exception:
                            pass
                    modules.append((f"vpp-{name}", display_name))
        return modules
    except Exception:
        return []


def cmd_status(args) -> int:
    """Show status of IMP services."""
    # Core services (always shown)
    services = [
        ("imp-apply-config", "Configuration auto-apply"),
        ("netns-dataplane", "Dataplane namespace"),
        ("vpp-core", "VPP core instance"),
    ]

    # Add enabled modules dynamically
    services.extend(get_enabled_modules())

    # Add remaining core services
    services.extend([
        ("frr", "FRR routing"),
        ("incus", "Incus containers"),
    ])

    print(f"\n{Colors.BOLD}IMP Service Status{Colors.NC}")
    print("=" * 50)

    for service, description in services:
        result = subprocess.run(
            ["systemctl", "is-active", service],
            capture_output=True,
            text=True,
            check=False
        )
        status = result.stdout.strip()

        if status == "active":
            status_color = Colors.GREEN
            status_icon = "●"
        elif status == "inactive":
            status_color = Colors.YELLOW
            status_icon = "○"
        else:
            status_color = Colors.RED
            status_icon = "✗"

        print(f"  {status_color}{status_icon}{Colors.NC} {description:<30} ({service})")

    print()

    # Show config status
    if CONFIG_FILE.exists():
        print(f"  {Colors.GREEN}✓{Colors.NC} Configuration: {CONFIG_FILE}")
    else:
        print(f"  {Colors.YELLOW}○{Colors.NC} Configuration: Not configured")
        print(f"    Run 'imp config edit' to configure")

    print()
    return 0


# =============================================================================
# Snapshot Commands
# =============================================================================

def get_current_be() -> str:
    """Get the current boot environment name."""
    # Find which dataset is mounted at /
    result = subprocess.run(
        ["zfs", "list", "-H", "-o", "name,mountpoint"],
        capture_output=True, text=True, check=True
    )
    for line in result.stdout.strip().split('\n'):
        parts = line.split('\t')
        if len(parts) == 2 and parts[1] == '/':
            # Return just the BE name (last component)
            return parts[0].split('/')[-1]
    raise RuntimeError("Could not determine current boot environment")


def run_zfs(args: list, check: bool = True) -> subprocess.CompletedProcess:
    """Run a ZFS command."""
    return subprocess.run(["zfs"] + args, capture_output=True, text=True, check=check)


def cmd_snapshot_list(args) -> int:
    """List all snapshots."""
    # Column widths: NAME=40, CREATED=24, USED=10, REFER=10, spaces=3, indent=2
    TABLE_WIDTH = 89

    print(f"\n{Colors.BOLD}Boot Environment Snapshots{Colors.NC}")
    print("=" * TABLE_WIDTH)

    # Use -H for tab-separated, -p for parseable (numeric) values
    result = run_zfs(["list", "-H", "-t", "snapshot", "-r", ZFS_ROOT, "-o", "name,creation,used,refer", "-s", "creation"], check=False)
    if result.returncode != 0:
        error(f"Failed to list snapshots: {result.stderr}")
        return 1

    if not result.stdout.strip():
        print("  No snapshots found")
    else:
        # Parse tab-separated output
        lines = result.stdout.strip().split('\n')
        if lines:
            print(f"  {'NAME':<40} {'CREATED':<24} {'USED':<10} {'REFER':<10}")
            print("  " + "-" * (TABLE_WIDTH - 2))
            for line in lines:
                parts = line.split('\t')
                if len(parts) >= 4:
                    name = parts[0].replace(f"{ZFS_ROOT}/", "")
                    # Creation is Unix timestamp with -H, convert to readable
                    try:
                        created = datetime.fromtimestamp(int(parts[1])).strftime("%Y-%m-%d %H:%M:%S")
                    except (ValueError, OSError):
                        created = parts[1]
                    print(f"  {name:<40} {created:<24} {parts[2]:<10} {parts[3]:<10}")

    print(f"\n{Colors.BOLD}Persistent Data Snapshots{Colors.NC}")
    print("=" * TABLE_WIDTH)

    result = run_zfs(["list", "-H", "-t", "snapshot", "-r", ZFS_PERSISTENT, "-o", "name,creation,used,refer", "-s", "creation"], check=False)
    if result.returncode != 0 or not result.stdout.strip():
        print("  No snapshots found")
    else:
        lines = result.stdout.strip().split('\n')
        if lines:
            print(f"  {'NAME':<40} {'CREATED':<24} {'USED':<10} {'REFER':<10}")
            print("  " + "-" * (TABLE_WIDTH - 2))
            for line in lines:
                parts = line.split('\t')
                if len(parts) >= 4:
                    name = parts[0].replace(f"{ZFS_PERSISTENT}/", "persistent/")
                    try:
                        created = datetime.fromtimestamp(int(parts[1])).strftime("%Y-%m-%d %H:%M:%S")
                    except (ValueError, OSError):
                        created = parts[1]
                    print(f"  {name:<40} {created:<24} {parts[2]:<10} {parts[3]:<10}")

    print()
    return 0


def cmd_snapshot_create(args) -> int:
    """Create a snapshot of current boot environment and persistent data."""
    # Generate snapshot name
    if args.name:
        snap_name = args.name
    else:
        snap_name = datetime.now().strftime("%Y%m%d-%H%M%S")

    try:
        current_be = get_current_be()
    except RuntimeError as e:
        error(str(e))
        return 1

    be_snapshot = f"{ZFS_ROOT}/{current_be}@{snap_name}"
    persistent_snapshot = f"{ZFS_PERSISTENT}@{snap_name}"

    log(f"Creating snapshot '{snap_name}'...")

    # Snapshot boot environment
    log(f"  Snapshotting boot environment: {current_be}")
    result = run_zfs(["snapshot", be_snapshot], check=False)
    if result.returncode != 0:
        error(f"Failed to snapshot boot environment: {result.stderr}")
        return 1

    # Snapshot persistent data (recursively for config and data)
    log(f"  Snapshotting persistent data")
    result = run_zfs(["snapshot", "-r", persistent_snapshot], check=False)
    if result.returncode != 0:
        error(f"Failed to snapshot persistent data: {result.stderr}")
        # Try to clean up BE snapshot
        run_zfs(["destroy", be_snapshot], check=False)
        return 1

    print(f"\n{Colors.GREEN}Snapshot '{snap_name}' created successfully{Colors.NC}")
    print(f"  Boot environment: {be_snapshot}")
    print(f"  Persistent data:  {persistent_snapshot}")
    print()
    return 0


def cmd_snapshot_rollback(args) -> int:
    """Rollback to a snapshot by cloning to a new boot environment."""
    snap_name = args.name

    try:
        current_be = get_current_be()
    except RuntimeError as e:
        error(str(e))
        return 1

    be_snapshot = f"{ZFS_ROOT}/{current_be}@{snap_name}"
    persistent_snapshot = f"{ZFS_PERSISTENT}@{snap_name}"

    # Verify snapshots exist
    result = run_zfs(["list", "-t", "snapshot", be_snapshot], check=False)
    if result.returncode != 0:
        error(f"Boot environment snapshot not found: {be_snapshot}")
        return 1

    result = run_zfs(["list", "-t", "snapshot", persistent_snapshot], check=False)
    if result.returncode != 0:
        warn(f"Persistent data snapshot not found: {persistent_snapshot}")
        if not args.force:
            print("Use --force to rollback without persistent data restore")
            return 1

    # Generate new BE name
    new_be_name = f"restored-{snap_name}"
    new_be = f"{ZFS_ROOT}/{new_be_name}"

    # Check if new BE already exists
    result = run_zfs(["list", new_be], check=False)
    if result.returncode == 0:
        error(f"Boot environment '{new_be_name}' already exists")
        print("Delete it first or choose a different snapshot")
        return 1

    print(f"\n{Colors.BOLD}Rollback Plan:{Colors.NC}")
    print(f"  Source snapshot:    {snap_name}")
    print(f"  New boot environment: {new_be_name}")
    print(f"  Current BE '{current_be}' will be preserved")
    print()

    if not args.yes:
        response = input("Proceed with rollback? [y/N]: ").strip().lower()
        if response != 'y':
            print("Aborted")
            return 0

    log("Creating new boot environment from snapshot...")

    # Clone BE snapshot to new dataset
    result = run_zfs(["clone", be_snapshot, new_be], check=False)
    if result.returncode != 0:
        error(f"Failed to clone boot environment: {result.stderr}")
        return 1

    # Set mountpoint
    result = run_zfs(["set", "mountpoint=/", new_be], check=False)
    if result.returncode != 0:
        error(f"Failed to set mountpoint: {result.stderr}")
        run_zfs(["destroy", new_be], check=False)
        return 1

    # Rollback persistent data (this is a true rollback, not clone)
    # Note: This will lose data newer than the snapshot!
    result = run_zfs(["list", "-t", "snapshot", persistent_snapshot], check=False)
    if result.returncode == 0:
        log("Rolling back persistent data...")
        warn("This will discard changes to persistent data since the snapshot!")
        if not args.yes:
            response = input("Rollback persistent data? [y/N]: ").strip().lower()
            if response == 'y':
                result = run_zfs(["rollback", "-r", persistent_snapshot], check=False)
                if result.returncode != 0:
                    warn(f"Failed to rollback persistent data: {result.stderr}")

    # Set as boot filesystem
    log("Setting new boot environment as default...")
    result = subprocess.run(
        ["zpool", "set", f"bootfs={new_be}", ZFS_POOL],
        capture_output=True, text=True, check=False
    )
    if result.returncode != 0:
        error(f"Failed to set bootfs: {result.stderr}")
        return 1

    print(f"\n{Colors.GREEN}Rollback complete!{Colors.NC}")
    print(f"  New boot environment: {new_be_name}")
    print(f"  Previous environment: {current_be} (preserved)")
    print(f"\n{Colors.YELLOW}Reboot to activate the restored system.{Colors.NC}")
    print()
    return 0


def clean_generated_configs(mount_point: str) -> None:
    """Remove generated configuration files from a mounted filesystem.

    This prepares the image for deployment by removing machine-specific configs.
    After deployment, the user runs 'imp config edit' or 'imp apply' to regenerate.
    """
    import glob

    # Files generated by configure-router.py / imp apply
    generated_files = [
        # VPP configs
        "etc/vpp/startup-core.conf",
        "etc/vpp/commands-core.txt",
        # FRR config
        "etc/frr/frr.conf",
        # Systemd units and network config
        "etc/systemd/system/netns-move-interfaces.service",
        "etc/systemd/network/10-management.network",
        # Helper scripts
        "usr/local/bin/vpp-core-config.sh",
        "usr/local/bin/incus-networking.sh",
    ]

    # Remove static generated files
    for rel_path in generated_files:
        full_path = Path(mount_point) / rel_path
        if full_path.exists():
            full_path.unlink()

    # Remove module configs (startup-*.conf, commands-*.txt except core templates)
    vpp_dir = Path(mount_point) / "etc/vpp"
    if vpp_dir.exists():
        for pattern in ["startup-*.conf", "commands-*.txt"]:
            for f in vpp_dir.glob(pattern):
                if f.name not in ["startup-core.conf", "commands-core.txt"]:
                    f.unlink()

    # Remove module service files (vpp-*.service)
    systemd_dir = Path(mount_point) / "etc/systemd/system"
    if systemd_dir.exists():
        for f in systemd_dir.glob("vpp-*.service"):
            # Keep vpp-core.service (static), remove module services
            if f.name != "vpp-core.service":
                f.unlink()

    # Reset hostname to default
    hostname_file = Path(mount_point) / "etc/hostname"
    if hostname_file.exists():
        hostname_file.write_text("imp\n")

    # Clean /etc/hosts to default
    hosts_file = Path(mount_point) / "etc/hosts"
    if hosts_file.exists():
        hosts_file.write_text("127.0.0.1\tlocalhost\n127.0.1.1\timp\n\n"
                              "::1\tlocalhost ip6-localhost ip6-loopback\n"
                              "ff02::1\tip6-allnodes\nff02::2\tip6-allrouters\n")


def cmd_snapshot_export(args) -> int:
    """Export a snapshot to a file for backup or deployment."""
    snap_name = args.name

    try:
        current_be = get_current_be()
    except RuntimeError as e:
        error(str(e))
        return 1

    be_snapshot = f"{ZFS_ROOT}/{current_be}@{snap_name}"
    persistent_snapshot = f"{ZFS_PERSISTENT}@{snap_name}"

    # Verify BE snapshot exists
    result = run_zfs(["list", "-t", "snapshot", be_snapshot], check=False)
    if result.returncode != 0:
        error(f"Snapshot not found: {be_snapshot}")
        return 1

    # For clean exports, we create a clone, clean it, and export from that
    clean_clone = None
    clean_snapshot = None
    clean_mount = None
    export_snapshot = be_snapshot  # Default: export original snapshot

    if getattr(args, 'clean', False):
        if args.full:
            error("--clean cannot be used with --full (clean is for deployment images)")
            return 1

        log("Creating clean export (removing generated configs)...")
        clean_clone = f"{ZFS_ROOT}/clean-export-tmp-{os.getpid()}"
        clean_mount = f"/tmp/clean-export-{os.getpid()}"

        try:
            # Clone the snapshot
            result = run_zfs(["clone", be_snapshot, clean_clone], check=False)
            if result.returncode != 0:
                error(f"Failed to create clone: {result.stderr}")
                return 1

            # Mount the clone
            os.makedirs(clean_mount, exist_ok=True)
            result = run_zfs(["set", f"mountpoint={clean_mount}", clean_clone], check=False)
            if result.returncode != 0:
                error(f"Failed to set mountpoint: {result.stderr}")
                run_zfs(["destroy", clean_clone], check=False)
                return 1

            result = run_zfs(["mount", clean_clone], check=False)
            if result.returncode != 0:
                error(f"Failed to mount clone: {result.stderr}")
                run_zfs(["destroy", clean_clone], check=False)
                return 1

            # Clean the generated configs
            clean_generated_configs(clean_mount)
            log("  Removed generated configuration files")

            # Create snapshot of clean clone
            clean_snapshot = f"{clean_clone}@clean"
            result = run_zfs(["snapshot", clean_snapshot], check=False)
            if result.returncode != 0:
                error(f"Failed to create clean snapshot: {result.stderr}")
                run_zfs(["unmount", clean_clone], check=False)
                run_zfs(["destroy", clean_clone], check=False)
                return 1

            export_snapshot = clean_snapshot
            log("  Created clean snapshot for export")

        except Exception as e:
            error(f"Clean export failed: {e}")
            if clean_clone:
                run_zfs(["unmount", clean_clone], check=False)
                run_zfs(["destroy", "-r", clean_clone], check=False)
            return 1

    # Generate output filename(s)
    hostname = os.uname().nodename
    base_name = f"{hostname}-{snap_name}"

    if args.full:
        # Full export creates two files: system and persistent
        if args.output:
            # Strip any .zfs.zst suffix from user-provided output
            base = str(args.output)
            for suffix in ['.zfs.zst', '.zst', '.zfs']:
                if base.endswith(suffix):
                    base = base[:-len(suffix)]
                    break
            base_name = base

        be_file = Path(f"{base_name}-system.zfs.zst")
        persistent_file = Path(f"{base_name}-persistent.zfs.zst")

        # Check for overwrites
        for f in [be_file, persistent_file]:
            if f.exists() and not args.yes:
                response = input(f"Output file {f} exists. Overwrite? [y/N]: ").strip().lower()
                if response != 'y':
                    print("Aborted")
                    return 0

        # Check for persistent snapshot
        result = run_zfs(["list", "-t", "snapshot", persistent_snapshot], check=False)
        if result.returncode != 0:
            error(f"Persistent snapshot not found: {persistent_snapshot}")
            print("Use without --full to export system only")
            return 1

        log(f"Exporting snapshot '{snap_name}'...")
        log("  Mode: Full backup (system + persistent data)")

        log(f"  Exporting boot environment to {be_file}...")
        result = subprocess.run(
            f"zfs send {be_snapshot} | zstd -T0 > {be_file}",
            shell=True, check=False
        )
        if result.returncode != 0:
            error("Failed to export boot environment")
            return 1

        log(f"  Exporting persistent data to {persistent_file}...")
        result = subprocess.run(
            f"zfs send -R {persistent_snapshot} | zstd -T0 > {persistent_file}",
            shell=True, check=False
        )
        if result.returncode != 0:
            error("Failed to export persistent data")
            be_file.unlink(missing_ok=True)
            return 1

        # Get file sizes
        be_size = be_file.stat().st_size / (1024 * 1024)
        persistent_size = persistent_file.stat().st_size / (1024 * 1024)

        print(f"\n{Colors.GREEN}Export complete!{Colors.NC}")
        print(f"  System:     {be_file} ({be_size:.1f} MB)")
        print(f"  Persistent: {persistent_file} ({persistent_size:.1f} MB)")
        print(f"\nTo restore on this or another system:")
        print(f"  install-imp --image {be_file} --persistent {persistent_file} /dev/sdX")
        print(f"\nOr to import into an existing system:")
        print(f"  imp snapshot import {be_file}")
        print(f"  imp snapshot import --persistent {persistent_file}")

    else:
        # System-only export
        if args.output:
            output_file = Path(args.output)
        else:
            output_file = Path(f"{base_name}-system.zfs.zst")

        if output_file.exists() and not args.yes:
            response = input(f"Output file {output_file} exists. Overwrite? [y/N]: ").strip().lower()
            if response != 'y':
                print("Aborted")
                return 0

        log(f"Exporting snapshot '{snap_name}'...")
        if getattr(args, 'clean', False):
            log("  Mode: Clean system image (for deployment)")
        else:
            log("  Mode: System only (for deployment to other routers)")
        log(f"  Exporting to {output_file}...")

        result = subprocess.run(
            f"zfs send {export_snapshot} | zstd -T0 > {output_file}",
            shell=True, check=False
        )
        if result.returncode != 0:
            error("Failed to export snapshot")
            output_file.unlink(missing_ok=True)
            # Clean up clone if it exists
            if clean_clone:
                run_zfs(["unmount", clean_clone], check=False)
                run_zfs(["destroy", "-r", clean_clone], check=False)
            return 1

        file_size = output_file.stat().st_size / (1024 * 1024)

        print(f"\n{Colors.GREEN}Export complete!{Colors.NC}")
        print(f"  File: {output_file} ({file_size:.1f} MB)")
        if getattr(args, 'clean', False):
            print(f"\n{Colors.YELLOW}Note: Generated configs removed. Run 'imp config edit' after install.{Colors.NC}")
        print(f"\nTo deploy on another router:")
        print(f"  install-imp --image {output_file} /dev/sdX")
        print(f"\nOr to import into an existing system:")
        print(f"  imp snapshot import {output_file}")

    # Clean up temporary clone if it was created
    if clean_clone:
        log("Cleaning up temporary clone...")
        run_zfs(["unmount", clean_clone], check=False)
        run_zfs(["destroy", "-r", clean_clone], check=False)
        if clean_mount:
            try:
                os.rmdir(clean_mount)
            except OSError:
                pass

    print()
    return 0


def cmd_snapshot_import(args) -> int:
    """Import a snapshot from a file."""
    input_file = Path(args.file)

    if not input_file.exists():
        error(f"File not found: {input_file}")
        return 1

    # Determine if this is a persistent data import
    if args.persistent:
        target_base = ZFS_PERSISTENT
        log(f"Importing persistent data from {input_file}...")
        warn("This will replace your current persistent data!")

        if not args.yes:
            response = input("Continue? [y/N]: ").strip().lower()
            if response != 'y':
                print("Aborted")
                return 0

        # For persistent, we do a destructive receive
        result = subprocess.run(
            f"zstd -d < {input_file} | zfs receive -F {target_base}",
            shell=True, check=False
        )
        if result.returncode != 0:
            error("Failed to import persistent data")
            return 1

        print(f"\n{Colors.GREEN}Persistent data restored!{Colors.NC}")
        return 0

    # System import - create new boot environment
    if args.name:
        new_be_name = args.name
    else:
        # Generate name from filename
        stem = input_file.stem
        if stem.endswith('.system'):
            stem = stem[:-7]
        if stem.endswith('.zfs'):
            stem = stem[:-4]
        new_be_name = f"imported-{stem}"

    new_be = f"{ZFS_ROOT}/{new_be_name}"

    # Check if BE already exists
    result = run_zfs(["list", new_be], check=False)
    if result.returncode == 0:
        error(f"Boot environment '{new_be_name}' already exists")
        print("Use -n/--name to specify a different name")
        return 1

    log(f"Importing system to boot environment '{new_be_name}'...")

    # Import the stream
    result = subprocess.run(
        f"zstd -d < {input_file} | zfs receive {new_be}",
        shell=True, check=False
    )
    if result.returncode != 0:
        error("Failed to import snapshot")
        return 1

    # Set mountpoint
    result = run_zfs(["set", "mountpoint=/", new_be], check=False)
    if result.returncode != 0:
        warn(f"Failed to set mountpoint: {result.stderr}")

    print(f"\n{Colors.GREEN}Import complete!{Colors.NC}")
    print(f"  New boot environment: {new_be_name}")
    print(f"\nTo boot into this system:")
    print(f"  zpool set bootfs={new_be} {ZFS_POOL}")
    print(f"  reboot")

    if not args.yes:
        response = input(f"\nSet '{new_be_name}' as default boot environment now? [y/N]: ").strip().lower()
        if response == 'y':
            result = subprocess.run(
                ["zpool", "set", f"bootfs={new_be}", ZFS_POOL],
                capture_output=True, text=True, check=False
            )
            if result.returncode == 0:
                print(f"{Colors.GREEN}Done! Reboot to use the imported system.{Colors.NC}")
            else:
                error(f"Failed to set bootfs: {result.stderr}")

    print()
    return 0


def cmd_snapshot_delete(args) -> int:
    """Delete a snapshot."""
    snap_name = args.name

    try:
        current_be = get_current_be()
    except RuntimeError as e:
        error(str(e))
        return 1

    be_snapshot = f"{ZFS_ROOT}/{current_be}@{snap_name}"
    persistent_snapshot = f"{ZFS_PERSISTENT}@{snap_name}"

    deleted = []

    # Delete BE snapshot
    result = run_zfs(["list", "-t", "snapshot", be_snapshot], check=False)
    if result.returncode == 0:
        if not args.yes:
            response = input(f"Delete {be_snapshot}? [y/N]: ").strip().lower()
            if response != 'y':
                print("Skipped")
            else:
                result = run_zfs(["destroy", be_snapshot], check=False)
                if result.returncode == 0:
                    deleted.append(be_snapshot)
                else:
                    error(f"Failed to delete: {result.stderr}")
        else:
            result = run_zfs(["destroy", be_snapshot], check=False)
            if result.returncode == 0:
                deleted.append(be_snapshot)

    # Delete persistent snapshot (recursively)
    result = run_zfs(["list", "-t", "snapshot", persistent_snapshot], check=False)
    if result.returncode == 0:
        if not args.yes:
            response = input(f"Delete {persistent_snapshot} (recursive)? [y/N]: ").strip().lower()
            if response != 'y':
                print("Skipped")
            else:
                result = run_zfs(["destroy", "-r", persistent_snapshot], check=False)
                if result.returncode == 0:
                    deleted.append(persistent_snapshot)
                else:
                    error(f"Failed to delete: {result.stderr}")
        else:
            result = run_zfs(["destroy", "-r", persistent_snapshot], check=False)
            if result.returncode == 0:
                deleted.append(persistent_snapshot)

    if deleted:
        print(f"\n{Colors.GREEN}Deleted:{Colors.NC}")
        for d in deleted:
            print(f"  {d}")
    else:
        warn("No snapshots found with that name")

    print()
    return 0


# =============================================================================
# Agent Command
# =============================================================================

def cmd_agent(args) -> int:
    """Enter LLM-powered agent mode."""
    try:
        from imp_agent import run_agent, get_ollama_host, get_ollama_model
    except ImportError as e:
        error(f"Failed to import agent module: {e}")
        print("  Ensure imp_agent.py is installed and python3-requests is available")
        return 1

    # Load config for context
    try:
        from imp_repl import MenuContext, load_config, CONFIG_FILE
        from dataclasses import asdict
        import json

        ctx = MenuContext()
        if CONFIG_FILE.exists():
            try:
                ctx.config = load_config(CONFIG_FILE)
                ctx.original_json = json.dumps(asdict(ctx.config), sort_keys=True)
            except Exception as e:
                warn(f"Failed to load config: {e}")
                ctx.config = None
    except ImportError:
        error("Failed to import REPL module")
        return 1

    # Get host and model from args or defaults
    host = getattr(args, 'ollama_host', None)
    model = getattr(args, 'model', None)

    run_agent(ctx, host=host, model=model)
    return 0


# =============================================================================
# Main
# =============================================================================

def main() -> int:
    # If no arguments, start interactive REPL
    if len(sys.argv) == 1:
        try:
            from imp_repl import run_repl
            return run_repl()
        except ImportError as e:
            error(f"Failed to import REPL module: {e}")
            print("Falling back to help display...")

    parser = argparse.ArgumentParser(
        description="IMP Router Management CLI",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  imp                           Enter interactive REPL
  imp config apply              Apply saved configuration
  imp config edit               Interactive configuration wizard
  imp shell routing             Open FRR/vtysh for BGP/OSPF
  imp shell core                Open VPP core CLI
  imp shell nat                 Open VPP module CLI (e.g., nat, nat64)
  imp shell                     List available shells
  imp snapshot list             List all snapshots
  imp snapshot create           Create a snapshot
  imp snapshot rollback NAME    Restore from snapshot
  imp snapshot export NAME      Export system to file (for deployment)
  imp snapshot export NAME --full  Export system + data (for backup)
  imp snapshot import FILE      Import system from file
  imp status                    Show service status
  imp agent                     Enter LLM-powered agent mode (Ollama)
"""
    )

    subparsers = parser.add_subparsers(dest="command", help="Command")

    # config subcommand
    config_parser = subparsers.add_parser("config", help="Configuration management")
    config_sub = config_parser.add_subparsers(dest="config_action")

    config_apply = config_sub.add_parser("apply", help="Apply configuration")
    config_apply.set_defaults(func=cmd_config_apply)

    config_edit = config_sub.add_parser("edit", help="Edit configuration interactively")
    config_edit.set_defaults(func=cmd_config_edit)

    config_show = config_sub.add_parser("show", help="Show current configuration")
    config_show.set_defaults(func=cmd_config_show)

    # shell subcommand - accepts any name (routing, core, or module name)
    shell_parser = subparsers.add_parser("shell", help="Access CLI shells")
    shell_parser.add_argument(
        "target",
        nargs="?",
        help="Shell target: routing (FRR), core (VPP), or module name"
    )
    shell_parser.set_defaults(func=cmd_shell)

    # status subcommand
    status_parser = subparsers.add_parser("status", help="Show service status")
    status_parser.set_defaults(func=cmd_status)

    # snapshot subcommand
    snapshot_parser = subparsers.add_parser("snapshot", help="Manage ZFS snapshots")
    snapshot_sub = snapshot_parser.add_subparsers(dest="snapshot_action")

    snapshot_list = snapshot_sub.add_parser("list", help="List all snapshots", aliases=["ls"])
    snapshot_list.set_defaults(func=cmd_snapshot_list)

    snapshot_create = snapshot_sub.add_parser("create", help="Create a snapshot")
    snapshot_create.add_argument("name", nargs="?", help="Snapshot name (default: timestamp)")
    snapshot_create.set_defaults(func=cmd_snapshot_create)

    snapshot_rollback = snapshot_sub.add_parser("rollback", help="Restore from snapshot")
    snapshot_rollback.add_argument("name", help="Snapshot name to restore")
    snapshot_rollback.add_argument("-y", "--yes", action="store_true", help="Skip confirmation prompts")
    snapshot_rollback.add_argument("-f", "--force", action="store_true", help="Continue even if persistent snapshot missing")
    snapshot_rollback.set_defaults(func=cmd_snapshot_rollback)

    snapshot_delete = snapshot_sub.add_parser("delete", help="Delete a snapshot", aliases=["rm"])
    snapshot_delete.add_argument("name", help="Snapshot name to delete")
    snapshot_delete.add_argument("-y", "--yes", action="store_true", help="Skip confirmation prompts")
    snapshot_delete.set_defaults(func=cmd_snapshot_delete)

    snapshot_export = snapshot_sub.add_parser("export", help="Export snapshot to file")
    snapshot_export.add_argument("name", help="Snapshot name to export")
    snapshot_export.add_argument("-o", "--output", help="Output file (default: auto-generated)")
    snapshot_export.add_argument("--full", action="store_true", help="Include persistent data (for full backup)")
    snapshot_export.add_argument("--clean", action="store_true", help="Remove generated configs for deployment image")
    snapshot_export.add_argument("-y", "--yes", action="store_true", help="Skip confirmation prompts")
    snapshot_export.set_defaults(func=cmd_snapshot_export)

    snapshot_import = snapshot_sub.add_parser("import", help="Import snapshot from file")
    snapshot_import.add_argument("file", help="File to import")
    snapshot_import.add_argument("-n", "--name", help="Name for new boot environment")
    snapshot_import.add_argument("--persistent", action="store_true", help="Import as persistent data (replaces current)")
    snapshot_import.add_argument("-y", "--yes", action="store_true", help="Skip confirmation prompts")
    snapshot_import.set_defaults(func=cmd_snapshot_import)

    # agent subcommand
    agent_parser = subparsers.add_parser("agent", help="Enter LLM-powered agent mode")
    agent_parser.add_argument("--ollama-host", help="Ollama host (default: from env/config or localhost:11434)")
    agent_parser.add_argument("--model", "-m", help="Ollama model (default: from env/config or gpt-oss:120b)")
    agent_parser.set_defaults(func=cmd_agent)

    # Parse and execute
    args = parser.parse_args()

    if not args.command:
        parser.print_help()
        return 0

    if args.command == "config" and not getattr(args, "config_action", None):
        config_parser.print_help()
        return 0

    if args.command == "snapshot" and not getattr(args, "snapshot_action", None):
        snapshot_parser.print_help()
        return 0

    if hasattr(args, "func"):
        return args.func(args)

    parser.print_help()
    return 0


if __name__ == "__main__":
    sys.exit(main())
