#!/bin/bash
#
# install-imp - Complete IMP router setup from Live CD
#
# This script:
#   1. Partitions a disk and creates a ZFS pool
#   2. Either bootstraps Debian OR receives a pre-built image
#   3. Installs VPP (from fd.io), FRR, and Incus (bootstrap mode only)
#   4. Installs configuration templates and scripts (bootstrap mode only)
#   5. Sets up zfsbootmenu for boot environment management
#
# Usage:
#   install-imp <disk>                       # Bootstrap from internet
#   install-imp --image <file.zfs.zst> <disk>  # Install from snapshot
#
# Examples:
#   install-imp /dev/sda
#   install-imp --image /tmp/imp-v1.0.0.zfs.zst /dev/sda
#
# Run from the IMP Installer ISO or a Debian Bookworm Live CD with ZFS support.
#

set -euo pipefail

# Defaults
POOL_NAME="tank"
ROOTFS="/mnt/root"
HOSTNAME="router"
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
CONFIG_DIR="${SCRIPT_DIR}/../config"
IMAGE_FILE=""
PERSISTENT_FILE=""
OUTPUT_FILE=""
INSTALL_MODE="bootstrap"  # "bootstrap", "image", or "build"
BUILD_POOL_FILE=""  # Temporary file for build mode pool

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m'

log() { echo -e "${GREEN}[+]${NC} $1"; }
warn() { echo -e "${YELLOW}[!]${NC} $1"; }
error() { echo -e "${RED}[ERROR]${NC} $1"; exit 1; }

usage() {
    echo "Usage: $0 [options] <disk>"
    echo "       $0 --output <file.zfs.zst>  (build mode)"
    echo ""
    echo "Arguments:"
    echo "  disk              Target disk (e.g., /dev/sda, /dev/nvme0n1)"
    echo ""
    echo "Options:"
    echo "  --image <file>      Install from pre-built ZFS snapshot (faster, offline)"
    echo "                      Created by: $0 --output or imp snapshot export"
    echo "  --persistent <file> Also restore persistent data (config + data)"
    echo "                      Created by: imp snapshot export --full <name>"
    echo "  --output <file>     Build mode: create image file instead of installing"
    echo "  --hostname <name>   Set hostname (default: router)"
    echo ""
    echo "Modes:"
    echo "  Bootstrap (default):  Downloads packages from internet (~15-30 min)"
    echo "  Image (--image):      Receives pre-built snapshot (~2-5 min)"
    echo "  Build (--output):     Creates deployable image file (~15-30 min)"
    echo ""
    echo "Examples:"
    echo "  $0 /dev/sda                                      # Bootstrap install"
    echo "  $0 --image system.zfs.zst /dev/sda               # Image install"
    echo "  $0 --image system.zfs.zst --persistent persistent.zfs.zst /dev/sda"
    echo "                                                   # Full restore"
    echo "  $0 --output imp-v1.0.0.zfs.zst                   # Build image"
    echo ""
    echo "Note: Bootstrap and build modes require internet access."
    echo "      Install to disk will DESTROY all data on the target disk."
    exit 1
}

# Parse arguments
DISK=""
while [[ $# -gt 0 ]]; do
    case "$1" in
        --image|-i)
            [[ -z "${2:-}" ]] && error "--image requires a file path"
            IMAGE_FILE="$2"
            INSTALL_MODE="image"
            shift 2
            ;;
        --persistent|-p)
            [[ -z "${2:-}" ]] && error "--persistent requires a file path"
            PERSISTENT_FILE="$2"
            shift 2
            ;;
        --output|-o)
            [[ -z "${2:-}" ]] && error "--output requires a file path"
            OUTPUT_FILE="$2"
            INSTALL_MODE="build"
            shift 2
            ;;
        --hostname)
            [[ -z "${2:-}" ]] && error "--hostname requires a name"
            HOSTNAME="$2"
            shift 2
            ;;
        --help|-h)
            usage
            ;;
        -*)
            error "Unknown option: $1"
            ;;
        *)
            DISK="$1"
            shift
            ;;
    esac
done

# Validate arguments
if [[ "$INSTALL_MODE" == "build" ]]; then
    # Build mode: output file required, no disk
    [[ -z "$OUTPUT_FILE" ]] && error "Build mode requires --output <file>"
    [[ -n "$DISK" ]] && error "Build mode doesn't use a disk target"
    [[ -n "$PERSISTENT_FILE" ]] && error "Build mode doesn't support --persistent"

    # Use a temporary pool name to avoid conflicts
    POOL_NAME="imp-build-$$"
else
    # Install modes: disk required
    [[ -z "$DISK" ]] && usage
    [[ ! -b "$DISK" ]] && error "Disk $DISK does not exist or is not a block device"
fi

# Validate image file if specified
if [[ "$INSTALL_MODE" == "image" ]]; then
    [[ ! -f "$IMAGE_FILE" ]] && error "Image file not found: $IMAGE_FILE"
    # Extract BE name from filename (hostname-snapname-system.zfs.zst -> use snapname)
    IMAGE_BASENAME=$(basename "$IMAGE_FILE")
    if [[ "$IMAGE_BASENAME" == *-system.zfs.zst ]]; then
        # Format: hostname-snapname-system.zfs.zst
        BE_NAME="${IMAGE_BASENAME%-system.zfs.zst}"
        BE_NAME="${BE_NAME##*-}"  # Get last part after hostname
    elif [[ "$IMAGE_BASENAME" == *.zfs.zst ]]; then
        # Generic format: name.zfs.zst
        BE_NAME="${IMAGE_BASENAME%.zfs.zst}"
    else
        BE_NAME="imported-$(date +%Y%m%d)"
    fi
fi

# Validate persistent file if specified
if [[ -n "$PERSISTENT_FILE" ]]; then
    [[ "$INSTALL_MODE" != "image" ]] && error "--persistent requires --image"
    [[ ! -f "$PERSISTENT_FILE" ]] && error "Persistent file not found: $PERSISTENT_FILE"
fi

# Check we're running as root
[[ $EUID -ne 0 ]] && error "This script must be run as root"

# Check ZFS is available
if ! command -v zpool &>/dev/null; then
    error "ZFS not available. Install with: apt install -y zfsutils-linux zfs-dkms && modprobe zfs"
fi

# Check if config directory exists (needed for bootstrap and build modes)
if [[ "$INSTALL_MODE" == "bootstrap" || "$INSTALL_MODE" == "build" ]]; then
    if [[ ! -d "$CONFIG_DIR" ]]; then
        # Try alternate location (installed on ISO)
        if [[ -d "/root/imp-build/config" ]]; then
            CONFIG_DIR="/root/imp-build/config"
            SCRIPT_DIR="/root/imp-build/scripts"
        else
            error "Cannot find config directory. Run from imp-build repository."
        fi
    fi
fi

# Check for existing pool (not needed for build mode - uses unique temp name)
EXISTING_POOL=""
if [[ "$INSTALL_MODE" != "build" ]]; then
    if zpool list "$POOL_NAME" &>/dev/null; then
        EXISTING_POOL="imported"
        warn "Pool '$POOL_NAME' is currently imported!"
    elif zpool import 2>/dev/null | grep -q "pool: $POOL_NAME"; then
        EXISTING_POOL="available"
        warn "Pool '$POOL_NAME' exists and can be imported!"
    fi
fi

# Confirm operation
echo ""
echo "=========================================="
if [[ "$INSTALL_MODE" == "build" ]]; then
    echo "  IMP Image Builder"
else
    echo "  IMP Router Setup"
fi
echo "=========================================="
echo ""
if [[ "$INSTALL_MODE" == "build" ]]; then
    echo "Build mode:   CREATE IMAGE"
    echo "Output file:  $OUTPUT_FILE"
    echo "Hostname:     $HOSTNAME"
    echo ""
    echo "This will create a deployable image containing:"
    echo "  - Debian Bookworm with ZFS root"
    echo "  - VPP (Vector Packet Processing)"
    echo "  - FRR (Free Range Routing)"
    echo "  - Incus (container runtime)"
    echo "  - IMP configuration tools"
    echo ""
    echo "The image can be installed with:"
    echo "  install-imp --image $OUTPUT_FILE /dev/sdX"
elif [[ "$INSTALL_MODE" == "image" ]]; then
    echo "Target disk:  $DISK"
    echo "Pool name:    $POOL_NAME"
    echo ""
    echo "Install mode: IMAGE (from exported snapshot)"
    echo "Image file:   $IMAGE_FILE"
    if [[ -n "$PERSISTENT_FILE" ]]; then
        echo "Persistent:   $PERSISTENT_FILE"
    fi
    echo "BE name:      $BE_NAME"
    echo ""
    echo "This will:"
    echo "  - Partition disk and create ZFS pool"
    echo "  - Receive system image as new boot environment"
    if [[ -n "$PERSISTENT_FILE" ]]; then
        echo "  - Restore persistent data (config + data)"
    else
        echo "  - Create empty persistent datasets"
    fi
    echo "  - Set up ZFSBootMenu"
else
    echo "Target disk:  $DISK"
    echo "Pool name:    $POOL_NAME"
    echo ""
    echo "Install mode: BOOTSTRAP (from internet)"
    echo "Hostname:     $HOSTNAME"
    echo ""
    echo "This will install:"
    echo "  - Debian Bookworm with ZFS root"
    echo "  - VPP (Vector Packet Processing)"
    echo "  - FRR (Free Range Routing)"
    echo "  - Incus (container runtime)"
    echo "  - IMP configuration tools"
fi
echo ""
if [[ -n "$EXISTING_POOL" ]]; then
    echo -e "${RED}WARNING: A ZFS pool named '$POOL_NAME' already exists!${NC}"
    echo "This pool will be DESTROYED and recreated."
    echo ""
fi
if [[ "$INSTALL_MODE" != "build" ]]; then
    warn "This will DESTROY ALL DATA on $DISK"
fi
echo ""
read -p "Type 'yes' to continue: " CONFIRM
[[ "$CONFIRM" != "yes" ]] && error "Aborted"

# Handle existing pool (not for build mode)
if [[ "$INSTALL_MODE" != "build" ]]; then
    if [[ "$EXISTING_POOL" == "imported" ]]; then
        log "Exporting existing pool '$POOL_NAME'..."
        zpool export "$POOL_NAME" || zpool export -f "$POOL_NAME" || error "Cannot export existing pool"
    fi

    if zpool import 2>/dev/null | grep -q "pool: $POOL_NAME"; then
        log "Destroying existing pool '$POOL_NAME'..."
        # Import and destroy
        zpool import -f "$POOL_NAME" 2>/dev/null || true
        zpool destroy -f "$POOL_NAME" 2>/dev/null || true
    fi
fi

# =============================================================================
# Build mode: Create temporary file-backed pool
# =============================================================================
if [[ "$INSTALL_MODE" == "build" ]]; then
    log "Creating temporary build environment..."

    # Create a 20GB sparse file for the build pool
    BUILD_POOL_FILE="/tmp/imp-build-$$.img"
    truncate -s 20G "$BUILD_POOL_FILE"

    # Create the temporary pool
    zpool create -f \
        -o ashift=12 \
        -O acltype=posixacl \
        -O canmount=off \
        -O compression=zstd \
        -O dnodesize=auto \
        -O normalization=formD \
        -O relatime=on \
        -O xattr=sa \
        -O mountpoint=none \
        "$POOL_NAME" "$BUILD_POOL_FILE"

    # Create the root dataset structure
    zfs create -o canmount=off -o mountpoint=none "${POOL_NAME}/ROOT"
    zfs create -o canmount=noauto -o mountpoint=/ "${POOL_NAME}/ROOT/default"

    # Mount for installation
    zfs set mountpoint="$ROOTFS" "${POOL_NAME}/ROOT/default"
    zfs mount "${POOL_NAME}/ROOT/default"

    BOOT_ENV="default"
fi

# =============================================================================
# Partition the disk (skip for build mode)
# =============================================================================
if [[ "$INSTALL_MODE" != "build" ]]; then
log "Partitioning $DISK..."

# Determine partition suffix (nvme uses 'p', sata/virtio don't)
if [[ "$DISK" == *"nvme"* ]] || [[ "$DISK" == *"loop"* ]]; then
    PART_PREFIX="${DISK}p"
else
    PART_PREFIX="${DISK}"
fi

sgdisk --zap-all "$DISK"

# Partition layout:
# 1: 1MB BIOS boot (legacy compatibility)
# 2: 512MB EFI System Partition
# 3: Remainder for ZFS
sgdisk -n1:1M:+1M -t1:EF02 "$DISK"
sgdisk -n2:0:+512M -t2:EF00 "$DISK"
sgdisk -n3:0:0 -t3:BF00 "$DISK"

# Wait for partitions to appear
sleep 2
partprobe "$DISK" 2>/dev/null || true
sleep 1

# Format ESP
log "Formatting EFI System Partition..."
mkfs.fat -F32 "${PART_PREFIX}2"

# =============================================================================
# Create ZFS pool
# =============================================================================
log "Creating ZFS pool..."

zpool create -f \
    -o ashift=12 \
    -o autotrim=on \
    -O acltype=posixacl \
    -O canmount=off \
    -O compression=zstd \
    -O dnodesize=auto \
    -O normalization=formD \
    -O relatime=on \
    -O xattr=sa \
    -O mountpoint=none \
    "$POOL_NAME" "${PART_PREFIX}3"

# Boot environment structure
zfs create -o canmount=off -o mountpoint=none "${POOL_NAME}/ROOT"

# Persistent data (survives across deployments)
if [[ -n "$PERSISTENT_FILE" ]]; then
    # Restore persistent data from backup
    log "Restoring persistent data from backup..."
    zstd -d < "$PERSISTENT_FILE" | zfs receive "${POOL_NAME}/persistent"
    # Fix mountpoint if needed
    zfs set mountpoint=/persistent "${POOL_NAME}/persistent"
else
    # Create empty persistent datasets
    zfs create -o canmount=off -o mountpoint=/persistent "${POOL_NAME}/persistent"
    zfs create "${POOL_NAME}/persistent/config"
    zfs create "${POOL_NAME}/persistent/data"
fi

fi  # End of disk partitioning section (not for build mode)

if [[ "$INSTALL_MODE" == "image" ]]; then
    # ==========================================================================
    # IMAGE MODE: Receive snapshot from exported file
    # ==========================================================================
    log "Receiving system image (this may take a few minutes)..."

    # Receive the snapshot - it comes as a full stream
    zstd -d < "$IMAGE_FILE" | zfs receive "${POOL_NAME}/ROOT/${BE_NAME}"

    # The received dataset may have wrong mountpoint from source system
    # Set it correctly for this new installation
    zfs set mountpoint=/ "${POOL_NAME}/ROOT/${BE_NAME}"
    zfs set canmount=noauto "${POOL_NAME}/ROOT/${BE_NAME}"

    # Mount for any post-receive configuration
    zfs set mountpoint="$ROOTFS" "${POOL_NAME}/ROOT/${BE_NAME}"
    zfs mount "${POOL_NAME}/ROOT/${BE_NAME}"

    BOOT_ENV="${BE_NAME}"

    # Mount virtual filesystems for chroot operations (image already has directories)
    log "Mounting virtual filesystems..."
    mount --rbind /dev  "$ROOTFS/dev"
    mount --make-rslave "$ROOTFS/dev"
    mount --rbind /proc "$ROOTFS/proc"
    mount --make-rslave "$ROOTFS/proc"
    mount --rbind /sys  "$ROOTFS/sys"
    mount --make-rslave "$ROOTFS/sys"

    # Mount ESP
    mkdir -p "$ROOTFS/boot/efi"
    mount "${PART_PREFIX}2" "$ROOTFS/boot/efi"

elif [[ "$INSTALL_MODE" == "bootstrap" ]]; then
    # ==========================================================================
    # BOOTSTRAP MODE: Create empty BE and install from internet
    # ==========================================================================
    zfs create -o canmount=noauto -o mountpoint=/ "${POOL_NAME}/ROOT/debian-initial"

    # Mount for installation
    zfs set mountpoint="$ROOTFS" "${POOL_NAME}/ROOT/debian-initial"
    zfs mount "${POOL_NAME}/ROOT/debian-initial"

    BOOT_ENV="debian-initial"
fi
# Note: BUILD mode pool and mount already set up earlier

if [[ "$INSTALL_MODE" == "bootstrap" || "$INSTALL_MODE" == "build" ]]; then
    # =========================================================================
    # BOOTSTRAP MODE: Build system from internet
    # =========================================================================

    # -------------------------------------------------------------------------
    # Bootstrap Debian
    # -------------------------------------------------------------------------
    log "Bootstrapping Debian Bookworm (this takes a few minutes)..."

    debootstrap \
        --include=linux-image-amd64,linux-headers-amd64,systemd,systemd-sysv,dbus,locales,keyboard-configuration,curl,gnupg,ca-certificates \
        bookworm \
        "$ROOTFS" \
        https://deb.debian.org/debian

    # -------------------------------------------------------------------------
    # Configure the system
    # -------------------------------------------------------------------------
    log "Configuring system..."

    # Mount virtual filesystems for chroot operations (debootstrap created directories)
    log "Mounting virtual filesystems..."
    mount --rbind /dev  "$ROOTFS/dev"
    mount --make-rslave "$ROOTFS/dev"
    mount --rbind /proc "$ROOTFS/proc"
    mount --make-rslave "$ROOTFS/proc"
    mount --rbind /sys  "$ROOTFS/sys"
    mount --make-rslave "$ROOTFS/sys"

    # Mount ESP (not for build mode - no disk)
    if [[ "$INSTALL_MODE" != "build" ]]; then
        mkdir -p "$ROOTFS/boot/efi"
        mount "${PART_PREFIX}2" "$ROOTFS/boot/efi"
    fi

    # Temporary DNS for chroot (systemd-resolved will take over after boot)
    rm -f "$ROOTFS/etc/resolv.conf"
    echo "nameserver 1.1.1.1" > "$ROOTFS/etc/resolv.conf"

    # Hostname
    echo "$HOSTNAME" > "$ROOTFS/etc/hostname"
    cat > "$ROOTFS/etc/hosts" << EOF
127.0.0.1   localhost
127.0.1.1   $HOSTNAME

::1         localhost ip6-localhost ip6-loopback
ff02::1     ip6-allnodes
ff02::2     ip6-allrouters
EOF

    # Apt sources (including backports for Incus)
    cat > "$ROOTFS/etc/apt/sources.list" << 'EOF'
deb http://deb.debian.org/debian bookworm main contrib
deb http://deb.debian.org/debian bookworm-updates main contrib
deb http://deb.debian.org/debian bookworm-backports main contrib
deb http://security.debian.org/debian-security bookworm-security main contrib
EOF

    # Locale
    sed -i 's/^# *en_US.UTF-8/en_US.UTF-8/' "$ROOTFS/etc/locale.gen"
    chroot "$ROOTFS" locale-gen
    echo 'LANG=en_US.UTF-8' > "$ROOTFS/etc/default/locale"

    # Initial network config (DHCP on all ethernet - will be replaced by configure-router.py)
    mkdir -p "$ROOTFS/etc/systemd/network"
    cat > "$ROOTFS/etc/systemd/network/20-wired.network" << 'EOF'
[Match]
Name=en*

[Network]
DHCP=yes
EOF

    # -------------------------------------------------------------------------
    # Pre-seed debconf for non-interactive installation
    # -------------------------------------------------------------------------
    log "Configuring non-interactive installation..."

    # Accept ZFS license
    cat > "$ROOTFS/tmp/debconf-selections" << 'EOF'
# Keyboard configuration - use US layout
keyboard-configuration keyboard-configuration/layoutcode string us
keyboard-configuration keyboard-configuration/model select Generic 105-key PC
keyboard-configuration keyboard-configuration/variant select English (US)
console-setup console-setup/charmap47 select UTF-8

# ZFS license acknowledgment
zfs-dkms zfs-dkms/note-incompatible-licenses note
EOF
    chroot "$ROOTFS" debconf-set-selections /tmp/debconf-selections
    rm "$ROOTFS/tmp/debconf-selections"

    # -------------------------------------------------------------------------
    # Install base packages
    # -------------------------------------------------------------------------
    log "Installing base packages..."
    chroot "$ROOTFS" apt-get update
    DEBIAN_FRONTEND=noninteractive chroot "$ROOTFS" apt-get install -y \
        zfsutils-linux \
        zfs-initramfs \
        systemd-resolved \
        iproute2 \
        dhcpcd-base \
        openssh-server \
        efibootmgr \
        zstd \
        console-setup \
        python3 \
        python3-jinja2 \
        python3-prompt-toolkit \
        python3-requests \
        python3-rich \
        python3-yaml \
        tshark

    # -------------------------------------------------------------------------
    # Setup fd.io repository and install VPP
    # -------------------------------------------------------------------------
    log "Setting up fd.io repository..."

    # Restore DNS (systemd-resolved install recreates the symlink)
    rm -f "$ROOTFS/etc/resolv.conf"
    echo "nameserver 1.1.1.1" > "$ROOTFS/etc/resolv.conf"

    mkdir -p "$ROOTFS/etc/apt/keyrings"
    # Run gpg inside the chroot where gnupg is installed
    curl -fsSL https://packagecloud.io/fdio/release/gpgkey | \
        chroot "$ROOTFS" gpg --dearmor -o /etc/apt/keyrings/fdio_release-archive-keyring.gpg

    # Copy fd.io sources list
    cp "$CONFIG_DIR/etc/apt/sources.list.d/fdio_release.list" "$ROOTFS/etc/apt/sources.list.d/"

    chroot "$ROOTFS" apt-get update

    log "Installing VPP..."
    DEBIAN_FRONTEND=noninteractive chroot "$ROOTFS" apt-get install -y \
        vpp \
        vpp-plugin-core \
        vpp-plugin-dpdk

    # -------------------------------------------------------------------------
    # Install FRR
    # -------------------------------------------------------------------------
    log "Installing FRR..."
    DEBIAN_FRONTEND=noninteractive chroot "$ROOTFS" apt-get install -y frr frr-pythontools

    # -------------------------------------------------------------------------
    # Install Incus from backports
    # -------------------------------------------------------------------------
    log "Installing Incus from backports..."
    DEBIAN_FRONTEND=noninteractive chroot "$ROOTFS" apt-get install -y -t bookworm-backports incus

    # -------------------------------------------------------------------------
    # Copy static configuration files
    # -------------------------------------------------------------------------
    log "Installing static configuration files..."

    # VPP directories
    mkdir -p "$ROOTFS/etc/vpp"
    mkdir -p "$ROOTFS/var/log/vpp"

    # FRR static configuration (daemons list, vtysh settings)
    cp "$CONFIG_DIR/etc/frr/daemons" "$ROOTFS/etc/frr/"
    cp "$CONFIG_DIR/etc/frr/vtysh.conf" "$ROOTFS/etc/frr/"
    chroot "$ROOTFS" chown -R frr:frr /etc/frr

    # Static systemd service units
    # Note: VPP module services (vpp-nat, vpp-nat64, etc.) are generated dynamically
    # by configure-router.py from templates/systemd/vpp-module.service.j2
    cp "$CONFIG_DIR/etc/systemd/system/netns-dataplane.service" "$ROOTFS/etc/systemd/system/"
    cp "$CONFIG_DIR/etc/systemd/system/vpp-core.service" "$ROOTFS/etc/systemd/system/"
    cp "$CONFIG_DIR/etc/systemd/system/vpp-core-config.service" "$ROOTFS/etc/systemd/system/"
    cp "$CONFIG_DIR/etc/systemd/system/incus-dataplane.service" "$ROOTFS/etc/systemd/system/"
    cp "$CONFIG_DIR/etc/systemd/system/incus-init.service" "$ROOTFS/etc/systemd/system/"
    cp "$CONFIG_DIR/etc/systemd/system/imp-apply-config.service" "$ROOTFS/etc/systemd/system/"

    # FRR drop-in to ensure it starts after VPP
    mkdir -p "$ROOTFS/etc/systemd/system/frr.service.d"
    cp "$CONFIG_DIR/etc/systemd/system/frr.service.d/after-vpp.conf" "$ROOTFS/etc/systemd/system/frr.service.d/"

    # Static helper scripts
    mkdir -p "$ROOTFS/usr/local/bin"
    cp "$CONFIG_DIR/usr/local/bin/wait-for-iface-load" "$ROOTFS/usr/local/bin/"
    chmod +x "$ROOTFS/usr/local/bin/"*

    # Create netns directory
    mkdir -p "$ROOTFS/etc/netns/dataplane"

    # -------------------------------------------------------------------------
    # Install Jinja2 templates for configure-router.py
    # -------------------------------------------------------------------------
    log "Installing configuration templates..."

    mkdir -p "$ROOTFS/etc/imp/templates/vpp"
    mkdir -p "$ROOTFS/etc/imp/templates/frr"
    mkdir -p "$ROOTFS/etc/imp/templates/systemd"
    mkdir -p "$ROOTFS/etc/imp/templates/scripts"

    cp "$CONFIG_DIR/templates/vpp/"*.j2 "$ROOTFS/etc/imp/templates/vpp/"
    cp "$CONFIG_DIR/templates/frr/"*.j2 "$ROOTFS/etc/imp/templates/frr/"
    cp "$CONFIG_DIR/templates/systemd/"*.j2 "$ROOTFS/etc/imp/templates/systemd/"
    cp "$CONFIG_DIR/templates/scripts/"*.j2 "$ROOTFS/etc/imp/templates/scripts/"

    # Install configure-router.py
    cp "$SCRIPT_DIR/configure-router.py" "$ROOTFS/usr/local/bin/"
    chmod +x "$ROOTFS/usr/local/bin/configure-router.py"

    # Create symlinks for convenience and Python imports
    ln -sf configure-router.py "$ROOTFS/usr/local/bin/configure-router"
    ln -sf configure-router.py "$ROOTFS/usr/local/bin/configure_router.py"

    # Install imp CLI, REPL, and Agent
    # Note: module_loader is now part of imp_lib.modules package
    cp "$SCRIPT_DIR/imp" "$ROOTFS/usr/local/bin/"
    cp "$SCRIPT_DIR/imp_repl.py" "$ROOTFS/usr/local/bin/"
    cp "$SCRIPT_DIR/imp_agent.py" "$ROOTFS/usr/local/bin/"
    chmod +x "$ROOTFS/usr/local/bin/imp"
    chmod +x "$ROOTFS/usr/local/bin/imp_repl.py"
    chmod +x "$ROOTFS/usr/local/bin/imp_agent.py"

    # Install imp_lib package to Python site-packages
    PYTHON_SITEPKG="$ROOTFS/usr/local/lib/python3/dist-packages"
    mkdir -p "$PYTHON_SITEPKG"
    cp -r "$SCRIPT_DIR/imp_lib" "$PYTHON_SITEPKG/"

    # Install module examples (templates for users to copy and customize)
    mkdir -p "$ROOTFS/usr/share/imp/module-examples"
    if [[ -d "$CONFIG_DIR/module-examples" ]]; then
        cp "$CONFIG_DIR/module-examples/"*.yaml "$ROOTFS/usr/share/imp/module-examples/" 2>/dev/null || true
    fi

    # -------------------------------------------------------------------------
    # Enable services
    # -------------------------------------------------------------------------
    log "Enabling services..."
    chroot "$ROOTFS" systemctl enable \
        systemd-networkd \
        systemd-resolved \
        ssh \
        imp-apply-config

    # Disable the default VPP service (we use vpp-core and vpp-<module> instead)
    chroot "$ROOTFS" systemctl disable vpp.service 2>/dev/null || true

    # -------------------------------------------------------------------------
    # Set root password
    # -------------------------------------------------------------------------
    log "Setting root password..."
    echo "root:router" | chroot "$ROOTFS" chpasswd
    warn "Default root password is 'router' - change it after first boot!"

else
    # =========================================================================
    # IMAGE MODE: System already configured, just need minor adjustments
    # =========================================================================
    log "Image received successfully"

    # The image contains everything - packages, configs, scripts
    # We may need to regenerate hostid and update initramfs for new hardware
fi

# =============================================================================
# Build mode: Export image and clean up
# =============================================================================
if [[ "$INSTALL_MODE" == "build" ]]; then
    log "Preparing image for export..."

    # Set ZFS properties for bootability
    zfs set canmount=noauto "${POOL_NAME}/ROOT/${BOOT_ENV}"
    zfs set org.zfsbootmenu:commandline="quiet" "${POOL_NAME}/ROOT/${BOOT_ENV}"

    # Clean up apt cache to reduce image size
    rm -rf "${ROOTFS}/var/cache/apt/archives"/*.deb
    rm -rf "${ROOTFS}/var/lib/apt/lists"/*

    # Unmount bind mounts (use recursive unmount for rbind mounts)
    log "Unmounting filesystems..."
    umount -R "$ROOTFS/dev" 2>/dev/null || umount -l "$ROOTFS/dev" 2>/dev/null || true
    umount -R "$ROOTFS/proc" 2>/dev/null || umount -l "$ROOTFS/proc" 2>/dev/null || true
    umount -R "$ROOTFS/sys" 2>/dev/null || umount -l "$ROOTFS/sys" 2>/dev/null || true

    sync
    sleep 1

    # Unmount ZFS filesystem before snapshot
    zfs unmount "${POOL_NAME}/ROOT/${BOOT_ENV}" 2>/dev/null || true

    # Set correct mountpoint for the image
    zfs set mountpoint=/ "${POOL_NAME}/ROOT/${BOOT_ENV}"

    # Create snapshot and export
    log "Creating snapshot and exporting image..."
    SNAPSHOT="${POOL_NAME}/ROOT/${BOOT_ENV}@release"
    zfs snapshot "$SNAPSHOT"
    zfs send "$SNAPSHOT" | zstd -T0 -10 > "$OUTPUT_FILE"

    # Get output file size
    OUTPUT_SIZE=$(ls -lh "$OUTPUT_FILE" | awk '{print $5}')

    # Clean up temporary pool
    log "Cleaning up build environment..."
    zpool destroy -f "$POOL_NAME"
    rm -f "$BUILD_POOL_FILE"

    echo ""
    echo "=========================================="
    log "Image build complete!"
    echo "=========================================="
    echo ""
    echo "Output: $OUTPUT_FILE ($OUTPUT_SIZE)"
    echo ""
    echo "To install this image on a router:"
    echo "  install-imp --image $OUTPUT_FILE /dev/sdX"
    echo ""
    echo "Or from the IMP Installer ISO:"
    echo "  install-imp --image $OUTPUT_FILE /dev/sda"
    echo ""

    exit 0
fi

# =============================================================================
# Common steps for disk install modes (bootstrap and image)
# =============================================================================

# Generate hostid (required for ZFS pool import on new hardware)
log "Generating hostid..."
zgenhostid -f -o "${ROOTFS}/etc/hostid"

# =============================================================================
# Install zfsbootmenu
# =============================================================================
log "Installing zfsbootmenu..."

mkdir -p "$ROOTFS/boot/efi/EFI/ZBM"
ZBM_EFI="$ROOTFS/boot/efi/EFI/ZBM/zfsbootmenu.efi"
if ! curl -fL --retry 3 --retry-delay 5 https://get.zfsbootmenu.org/efi -o "$ZBM_EFI"; then
    error "Failed to download zfsbootmenu EFI binary"
fi

# Verify the download succeeded (should be ~15-20MB)
ZBM_SIZE=$(stat -f%z "$ZBM_EFI" 2>/dev/null || stat -c%s "$ZBM_EFI" 2>/dev/null || echo 0)
if [[ "$ZBM_SIZE" -lt 1000000 ]]; then
    error "zfsbootmenu download appears corrupted (size: $ZBM_SIZE bytes)"
fi
log "Downloaded zfsbootmenu ($((ZBM_SIZE / 1024 / 1024))MB)"

# Also copy to UEFI fallback path for VMs and systems that don't persist NVRAM
mkdir -p "$ROOTFS/boot/efi/EFI/BOOT"
cp "$ZBM_EFI" "$ROOTFS/boot/efi/EFI/BOOT/BOOTX64.EFI"
log "Installed zfsbootmenu to fallback path EFI/BOOT/BOOTX64.EFI"

# Remove any existing ZFSBootMenu entries to avoid duplicates
log "Cleaning up existing ZFSBootMenu EFI entries..."
for entry in $(chroot "$ROOTFS" efibootmgr | grep -i "ZFSBootMenu" | grep -oP 'Boot\K[0-9A-Fa-f]{4}'); do
    chroot "$ROOTFS" efibootmgr -b "$entry" -B 2>/dev/null || true
done

# Create EFI boot entry
chroot "$ROOTFS" efibootmgr -c -d "$DISK" -p 2 -L "ZFSBootMenu" -l '\EFI\ZBM\zfsbootmenu.efi'

# =============================================================================
# Set ZFS boot properties
# =============================================================================
log "Setting ZFS boot properties..."

zpool set bootfs="${POOL_NAME}/ROOT/${BOOT_ENV}" "$POOL_NAME"
zfs set org.zfsbootmenu:commandline="quiet" "${POOL_NAME}/ROOT/${BOOT_ENV}"

# Regenerate initramfs (important for new hardware in image mode)
log "Regenerating initramfs..."
chroot "$ROOTFS" update-initramfs -u -k all

# =============================================================================
# Finalize
# =============================================================================
log "Finalizing installation..."

# Unmount bind mounts first (use recursive unmount for rbind mounts)
log "Unmounting filesystems..."
umount "$ROOTFS/boot/efi" 2>/dev/null || warn "ESP already unmounted"
umount -R "$ROOTFS/dev" 2>/dev/null || umount -l "$ROOTFS/dev" 2>/dev/null || true
umount -R "$ROOTFS/proc" 2>/dev/null || umount -l "$ROOTFS/proc" 2>/dev/null || true
umount -R "$ROOTFS/sys" 2>/dev/null || umount -l "$ROOTFS/sys" 2>/dev/null || true

# Give things a moment to settle
sync
sleep 2

# Unmount ZFS filesystem before changing mountpoint
log "Setting ZFS mountpoints for booting..."
zfs unmount "${POOL_NAME}/ROOT/${BOOT_ENV}" 2>/dev/null || true

# Set mountpoints for booting (must be done while unmounted)
zfs set mountpoint=/ "${POOL_NAME}/ROOT/${BOOT_ENV}"

# Set persistent mountpoints (handles both fresh and restored cases)
zfs set mountpoint=/persistent "${POOL_NAME}/persistent" 2>/dev/null || true
# Only set child mountpoints if they exist (they might not in restored case with different structure)
if zfs list "${POOL_NAME}/persistent/config" &>/dev/null; then
    zfs set mountpoint=/persistent/config "${POOL_NAME}/persistent/config"
fi
if zfs list "${POOL_NAME}/persistent/data" &>/dev/null; then
    zfs set mountpoint=/persistent/data "${POOL_NAME}/persistent/data"
fi

# Verify mountpoint is correct
VERIFY_MP=$(zfs get -H -o value mountpoint "${POOL_NAME}/ROOT/${BOOT_ENV}")
if [[ "$VERIFY_MP" != "/" ]]; then
    error "Mountpoint not set correctly (got: $VERIFY_MP, expected: /)"
fi
log "Mountpoint verified: $VERIFY_MP"

# Export pool
log "Exporting ZFS pool..."
zpool export "$POOL_NAME" || {
    warn "Pool busy, trying force export..."
    sleep 2
    zpool export -f "$POOL_NAME" || warn "Could not export pool - reboot will handle it"
}

echo ""
echo "=========================================="
log "IMP Router setup complete!"
echo "=========================================="
echo ""
echo "Boot environment: ${BOOT_ENV}"
echo ""
if [[ "$INSTALL_MODE" == "image" ]]; then
    echo "Installed from: $(basename "$IMAGE_FILE")"
    if [[ -n "$PERSISTENT_FILE" ]]; then
        echo "Persistent:     $(basename "$PERSISTENT_FILE") (restored)"
    fi
    echo ""
    echo "The system image includes all packages and configuration."
    if [[ -n "$PERSISTENT_FILE" ]]; then
        echo "Persistent data (including router config) was restored."
        echo "The configuration will be applied on first boot."
    else
        echo "If the source system had a saved configuration, it will be"
        echo "applied on first boot via imp-apply-config service."
    fi
else
    echo "Installed components:"
    echo "  - Debian Bookworm with ZFS root"
    echo "  - VPP (Vector Packet Processing) from fd.io"
    echo "  - FRR (Free Range Routing)"
    echo "  - Incus (container runtime)"
    echo "  - ZFSBootMenu"
fi
echo ""
echo "Next steps:"
echo "  1. Remove the Live CD/USB"
echo "  2. Reboot"
if [[ "$INSTALL_MODE" == "bootstrap" ]]; then
    echo "  3. Login as root (password: router)"
    echo "  4. Run 'imp config edit' to set up networking"
    echo "  5. Change the root password!"
else
    echo "  3. Login with the credentials from the source system"
    echo "  4. Run 'imp config edit' if network reconfiguration needed"
fi
echo ""
echo "IMP CLI commands:"
echo "  imp                 - Interactive configuration REPL"
echo "  imp config edit     - Configure router interactively"
echo "  imp config apply    - Re-apply saved configuration"
echo "  imp status          - Show service status"
echo "  imp shell routing   - FRR/BGP shell (vtysh)"
echo "  imp shell core      - VPP core CLI"
echo "  imp shell nat       - VPP NAT CLI"
echo ""
echo "To reboot now:"
echo "  reboot              - Normal reboot"
echo "  reboot -f           - Force reboot (if normal fails)"
echo ""
